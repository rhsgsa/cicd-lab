document.addEventListener('DOMContentLoaded', function () {
  // If there is a query string, we need to fix up the page to make sure the query string is properly preserved
  var desiredQueryString = new URLSearchParams(window.location.search)
  if (desiredQueryString.toString()) {
    // If there are query parameters (searchparams) in the current window location
    // then iterate over all them replacing text and link-hrefs that contain them
    for (var k of desiredQueryString.keys()) {
      replaceParamsInNodes(document.body, k, desiredQueryString.get(k))
    }

    // NOTE: Once all links have been query string replaced, then attempt to preserve the query string
    // for all references
    preserveQueryString(desiredQueryString)
  }

  function preserveQueryString (desiredQueryString) {
    //Handle links
    var allQueryParamLinks = document.querySelectorAll('.query-params-link, .home-link, .params-link, .nav-link')
    if (allQueryParamLinks) {
      allQueryParamLinks.forEach(appendQueryStringToHref)
    }

    // Handle breadcrumb navigation links
    var paramLinks = document.querySelectorAll('.breadcrumbs ul li a')
    if (paramLinks) {
      paramLinks.forEach(appendQueryStringToHref)
    }

    // Handle xrefs, which are anchor elements generated by antora with the page attribute
    var xrefLinks = document.querySelectorAll('a.page')
    if (xrefLinks) {
      xrefLinks.forEach(appendQueryStringToHref)
    }
  }

  function appendQueryStringToHref (el) {
    // NOTE: desiredQueryString captured from above
    if (desiredQueryString.toString()) {
      try {
        var hrefURL = new URL(el.href)
        for (var k of desiredQueryString.keys()) {
          hrefURL.searchParams.set(k, desiredQueryString.get(k))
        }

        el.href = hrefURL.toString()
      } catch (err) {
        console.error('Unable to append query string to element [' + el.innerHTML + ']: ' + err)
      }
    }
  }

  // refreshing links

  function replaceParamsInNodes (node, key, value) {
    // Don't descend into any nodes that are children of the no-query-replace class
    if ((typeof node.classList !== 'undefined') && (node.classList.contains('no-query-replace'))) {
      return
    }

    if (node.nodeType === 3) {
      var text = node.data
      node.data = applyPattern(text, key, value)
    }
    if (node.nodeType === 1 && node.nodeName !== 'SCRIPT') {
      for (var i = 0; i < node.childNodes.length; i++) {
        replaceParamsInNodes(node.childNodes[i], key, value)
      }

      // handle link elements
      if (node.href) {
        node.href = applyPattern(node.href, key, value)
      }
    }
  }

  function applyPattern (str, key, value) {
    //(%25key%25|%key%) %25 is urlencode value of %
    var pattern = '(' + '%25' + key + '%25' + '|' + '%' + key + '%' + ')'

    // The following pattern was introduced in commit db18c1dca8e101d0f3a2e512c43ada19168e5afe,
    // but it's not clear why the negative lookbehind was added. Keeping here
    // in case we need a revert in the future
    // var pattern = '(' + '%25' + key + '%25' +
    //   '|(?<!-)' + '%' + key + '%' + '(?!-))'

    var re = new RegExp(pattern, 'gi')
    return str.replace(re, value)
  }
})
